package sockets;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Date;
import java.lang.Object;

import javax.microedition.io.Connection;
import javax.microedition.io.Connector;
import javax.microedition.io.Datagram;
import javax.microedition.io.DatagramConnection;
import javax.microedition.io.SocketConnection;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.Location;

import com.cinterion.coap.utils.DatagramWriter;
import com.cinterion.coap.utils.InetAddress;

import gerenciadores.GerenciadorAtc;
import gerenciadores.GerenciadorConexao;
import gerenciadores.GerenciadorDisponibilidade;
import gerenciadores.GerenciadorHardware;
import hardware.EEPROM;
import hardware.GPIO;
import hardware.Modulo;
import hardware.SERIAL0;
import hardware.SERIAL0485;
import hardware.SERIAL1;
import modbus.Ferramentas;
import modbus.Mapa;
import modbus.Modbus;
import threads.ThreadComunicacao;
import threads.ThreadInatividadeComunicacao;
import threads.ThreadLedConexao;
import threads.ThreadTimeOutsFabricante;
import threads.ThreadTimeOutsRotemanto;
import threads.ThreadWatchDog;
import utilitarios.Defines;
import utilitarios.Leituras;
import utilitarios.Prints;
import utilitarios.Timer;
import utilitarios.Utilitarios;

public class SocketRoteamento2 {

	private static SocketRoteamento2 instance = null;
	private volatile String host;
	private volatile String portaTCP;
	private volatile static String accessPointName;
	private volatile String bearerValue;
	private volatile String userName;
	private volatile String password;
	private volatile int protocolo = 1;
	byte[] buffer1 = new byte[1480];
	private String paremetrosConexao;
	int tempoInatividade;
	int tempoValidacao;
	int tempoManutencao;
	int tempoOperadoraRedundante;
	public static boolean roteandoSerial = false;
	boolean bootLoader = false;
	public static boolean loopTimers;
	public static int bytesRoteamento;
	public static int numeroMensagensTrafegadasRoteamento;
	int tentativasConexao;
	int flagReinicaInatividade = 0;
	public static volatile int tentativasConexaoServidor = 3; // possibilidade
																// aumentar o
																// numero de
																// tentativas
																// apenas
																// modificando o
																// valor da
																// variavel
	int ligado = 5;
	int desligado = 4;
	static boolean sendDgram = true;
	public static volatile boolean loopConexao = true;
	int tempoPermanenciaServidorRedundante;
	boolean conectouServidorRedundante = false;
	boolean conectouOperadoraRedundante = false;
	public static volatile boolean ftpFlagBoot = false;
	int valor;
	public static boolean DEBUG;
	InputStream inputStream;
	OutputStream outPutStream;
	SocketConnection socketRoteamento;
	Datagram datagram = null;
	DatagramConnection datagramConnection;
	DataInputStream datainputStream;
	DataOutputStream dataoutPutStream;
	boolean descTCP;
	boolean dnsAtivado = false;
	boolean dnsPrimario = false;
	boolean dnsSecundario = false;
	int tentativasValidacao = 0;
	boolean ativarDns;
	boolean trocaSimCard = false;
	public boolean estadoCMD;

	private void init() {

	}

	public static SocketRoteamento2 getInstance() {
		if (instance == null) {
			instance = new SocketRoteamento2();
			instance.init();
		}

		return instance;
	}

	public void configuraParametrosConexao(String host, String portaTCP, String bearerValue, String accessPointName,
			String userName, String password, int protoclo) {

		this.host = host;
		this.portaTCP = portaTCP;
		this.bearerValue = bearerValue;
		this.userName = userName;
		this.password = password;
		this.protocolo = protocolo;

		// 0 - Para protocolo TCP
		if (protocolo == 0) {

			this.paremetrosConexao = "socket://" + this.host + ":" + this.portaTCP + ";bearer_type=" + this.bearerValue
					+ ";context_id=1" + ";access_point=" + this.accessPointName + ";username=" + this.userName
					+ ";password=" + this.password;

		}

		// 1 - Para protocolo UDP
		else {

			this.paremetrosConexao = "datagram://" + this.host + ":" + this.portaTCP + ";bearer_type="
					+ this.bearerValue + ";context_id=1" + ";access_point=" + this.accessPointName + ";username="
					+ this.userName + ";password=" + this.password;

		}

		System.out.println(paremetrosConexao);

	}

	/*
	 * //Classe que irá identifdicar qual é protocolo definido public int
	 * getProtocolo(){
	 * 
	 * return protocolo; }
	 */

	public String getHost() {
		return host;
	}

	public void setHost(String host) {
		this.host = host;
	}

	public String getAccessPointName() {
		return accessPointName;
	}

	public void setAccessPointName(String accessPointName) {
		this.accessPointName = accessPointName;
	}

	public String getParemetrosConexao() {
		return paremetrosConexao;
	}

	public void setParemetrosConexao(String paremetrosConexao) {
		this.paremetrosConexao = paremetrosConexao;
	}

	public int getTempoInatividade() {
		return tempoInatividade;
	}

	public void setTempoInatividade(int tempoInatividade) {
		this.tempoInatividade = tempoInatividade;
	}

	public int getTempoValidacao() {
		return tempoValidacao;
	}

	public void setTempoValidacao(int tempoValidacao) {
		this.tempoValidacao = tempoValidacao;
	}

	public int getTempoManutencao() {
		return tempoManutencao;
	}

	public void setTempoManutencao(int tempoManutencao) {
		this.tempoManutencao = tempoManutencao;
	}

	public static boolean isRoteandoerial() {
		return roteandoSerial;
	}

	public void setRoteandoSerial(boolean roteandondoSerial) {
		this.roteandoSerial = roteandondoSerial;
	}

	public int getTentativasConexao() {
		return tentativasConexao;
	}

	public void setTentativasConexao(int tentativasConexao) {
		this.tentativasConexao = tentativasConexao;
	}

	public int getTempoPermanenciaServidorRedundante() {
		return tempoPermanenciaServidorRedundante;
	}

	public void setTempoPermanenciaServidorRedundante(int tempoPermanenciaServidorRedundante) {
		this.tempoPermanenciaServidorRedundante = tempoPermanenciaServidorRedundante;
	}

	public String getPortaTCP() {
		return portaTCP;
	}

	public void setPortaTCP(String portaTCP) {
		this.portaTCP = portaTCP;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public void carregaConfiguracoesConexao1(int opcao, boolean ativarDns) {

		if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_NIV_PRI]) == 1) {

			Utilitarios.getInstance().setaFlag(2, 0);

		} else {

			Utilitarios.getInstance().setaFlag(2, 1);
		}

		if (reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 1) {

			conectouOperadoraRedundante = false;

		} else {

			if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 1) {

				if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1) {

					if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_NIV_PRI]) == 1) {

						conectouOperadoraRedundante = true;

						System.out.println("SIM1 operadora principal");
					} else {

						conectouOperadoraRedundante = false;

						System.out.println("SIM1 operadora redundante");
					}

				}
			} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 2) {

				if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1) {

					if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_NIV_PRI]) == 1) {

						conectouOperadoraRedundante = true;

						System.out.println("SIM2 operadora principal");

					} else {

						conectouOperadoraRedundante = false;

						System.out.println("SIM2 operadora redundante");
					}
				}
			} else {

				conectouOperadoraRedundante = false;
			}
		}

		if (opcao == 1) {

			if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 1) {

				System.out.println("opcao 1 - simn 1");

				Utilitarios.getInstance().setaFlag(13, 0);// 13 SINALIZA SE O
															// MODEM ESTA NO
															// SERVIDOR PRIN = 0
															// OU REDUN =1

				Utilitarios.getInstance().setaFlag(1, 0); // FLAG SIM CARD
															// SELECIONADO 0 ==
															// SIM 1

				if (ativaDns(1, 1)) { // VERIFICA SE O IP SERVIDOR PRIMARIO ESTÁ
										// VAZIO

					dnsAtivado = true;

				} else {

					dnsAtivado = false;
				}

				if (dnsAtivado || ativarDns) {

					if (SocketUtils.getInstance().lerDnsPirmario() != null
							&& !SocketUtils.getInstance().lerDnsPirmario().equals("")) { // VERIFICA
																							// SE
																							// O
																							// DNS
																							// PRIMARIO
																							// ESTA
																							// VAZIO

						this.host = SocketUtils.getInstance().lerDnsPirmario().trim();

						dnsAtivado = true;

					} else {

						this.host = SocketUtils.getInstance().simIP1(1);

						dnsAtivado = false;
					}

				} else {

					this.host = SocketUtils.getInstance().simIP1(1);

					dnsAtivado = false;
				}

				this.portaTCP = SocketUtils.getInstance().simPortaTCP(1);
				this.bearerValue = SocketUtils.getInstance().configuraBearerControl("IPV4");
				this.accessPointName = SocketUtils.getInstance().lerApn(1);
				this.userName = SocketUtils.getInstance().lerUsuarioApn(1);
				this.password = SocketUtils.getInstance().lerSenhaApn(1);

				configuraParametrosConexao(host, portaTCP, bearerValue, accessPointName, userName, password, protocolo);

			} else {

				System.out.println("opcao 1 - simn 2");

				Utilitarios.getInstance().setaFlag(13, 0);// 13 SINALIZA SE O
															// MODEM ESTA NO
															// SERVIDOR PRIN = 0
															// OU REDUN =1

				Utilitarios.getInstance().setaFlag(1, 1); // FLAG SIM CARD
															// SELECIONADO 1 ==
															// SIM 2

				if (ativaDns(1, 2)) {

					dnsAtivado = true;

				} else {

					dnsAtivado = false;

				}

				if (dnsAtivado || ativarDns) {

					if (SocketUtils.getInstance().lerDnsSecundario() != null
							&& !SocketUtils.getInstance().lerDnsSecundario().equals("")) {

						this.host = SocketUtils.getInstance().lerDnsSecundario().trim();

						dnsAtivado = true;

					} else {

						this.host = SocketUtils.getInstance().simIP1(2);

						dnsAtivado = true;
					}

				} else {

					this.host = SocketUtils.getInstance().simIP1(2);

				}

				this.portaTCP = SocketUtils.getInstance().simPortaTCP(2);
				this.bearerValue = SocketUtils.getInstance().configuraBearerControl("IPV4");
				this.accessPointName = SocketUtils.getInstance().lerApn(2);
				this.userName = SocketUtils.getInstance().lerUsuarioApn(2);
				this.password = SocketUtils.getInstance().lerSenhaApn(2);
				configuraParametrosConexao(host, portaTCP, bearerValue, accessPointName, userName, password, protocolo);
			}

		} else {

			if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 1) {

				System.out.println("opcao 2 - simn 1");

				Utilitarios.getInstance().setaFlag(13, 1);// 13 SINALIZA SE O
															// MODEM ESTA NO
															// SERVIDOR PRIN = 0
															// OU REDUN// =1

				Utilitarios.getInstance().setaFlag(1, 0); // FLAG SIM CARD
															// SELECIONADO 0 ==
															// SIM 1

				if (ativaDns(2, 1)) { // VERIFICA SE O ENDERECO IP SERVIDOR
										// PRIMARIO ESTA VAZIO

					dnsAtivado = true;

				} else {

					dnsAtivado = false;

				}

				if (dnsAtivado || ativarDns) {

					if (SocketUtils.getInstance().lerDnsSecundario() != null
							&& !SocketUtils.getInstance().lerDnsSecundario().equals("")) { // VERIFICA
																							// SE
																							// O
																							// DNS
																							// PRIMARIO
																							// ESTA
																							// VAZIO

						this.host = SocketUtils.getInstance().lerDnsSecundario().trim();

						dnsAtivado = true;

					} else {

						this.host = SocketUtils.getInstance().simIP2(1);// PUXA
																		// O
																		// ENDEREÇO
																		// DE
																		// IP,
																		// MESMO
																		// QUE
																		// ESTEJA
																		// ZERADO

						dnsAtivado = false;
					}

				} else {

					this.host = SocketUtils.getInstance().simIP2(1);

					dnsAtivado = false;

				}

				this.portaTCP = SocketUtils.getInstance().simPortaTCPSecundaria(1);
				this.accessPointName = SocketUtils.getInstance().lerApn(1);
				this.bearerValue = SocketUtils.getInstance().configuraBearerControl("IPV4");
				this.userName = SocketUtils.getInstance().lerUsuarioApn(1);
				this.password = SocketUtils.getInstance().lerSenhaApn(1);
				configuraParametrosConexao(host, portaTCP, bearerValue, accessPointName, userName, password, protocolo);

			} else {

				System.out.println("opcao 2 - simn 2");

				Utilitarios.getInstance().setaFlag(13, 1);// 13 SINALIZA SE O
															// MODEM ESTA NO
															// SERVIDOR PRIN = 0
															// OU REDUN =1
				Utilitarios.getInstance().setaFlag(1, 1); // FLAG SIM CARD
															// SELECIONADO 1 ==
															// SIM 2

				if (ativaDns(2, 2)) { // VERIFICA SE O ENDERECO IP SERVIDOR
										// PRIMARIO ESTA VAZIO

					dnsAtivado = true;

				} else {

					dnsAtivado = false;

				}

				if (dnsAtivado || ativarDns) {

					if (SocketUtils.getInstance().lerDnsSecundario() != null
							&& !SocketUtils.getInstance().lerDnsSecundario().equals("")) { // VERIFICA
																							// SE
																							// O
																							// DNS
																							// PRIMARIO
																							// ESTA
																							// VAZIO

						this.host = SocketUtils.getInstance().lerDnsSecundario().trim();

						dnsAtivado = true;

					} else {

						this.host = SocketUtils.getInstance().simIP2(2);

						dnsAtivado = false;
					}

				} else {

					this.host = SocketUtils.getInstance().simIP2(2);

					dnsAtivado = false;

				}

				this.portaTCP = SocketUtils.getInstance().simPortaTCPSecundaria(2);
				this.accessPointName = SocketUtils.getInstance().lerApn(2);
				this.bearerValue = SocketUtils.getInstance().configuraBearerControl("IPV4");
				this.userName = SocketUtils.getInstance().lerUsuarioApn(2);
				this.password = SocketUtils.getInstance().lerSenhaApn(2);

				configuraParametrosConexao(host, portaTCP, bearerValue, accessPointName, userName, password, protocolo);

			}

		}

	}

	public void identificaIpOperadora(String resposta) {

		if (resposta != null) {

			if (DEBUG) {
				System.out.println("[log] Salvando IP fornecido pela operadora no mapa Modbus ");
			}

			try {

				String oct1 = resposta.substring(0, resposta.indexOf("."));
				String oct2 = resposta.substring(resposta.indexOf(".") + 1,
						resposta.indexOf(".", resposta.indexOf(".") + 2));
				resposta = resposta.substring(resposta.indexOf(".") + 1);
				String oct3 = resposta.substring(resposta.indexOf(".") + 1,
						resposta.indexOf(".", resposta.indexOf(".") + 2));
				resposta = resposta.substring(resposta.indexOf(".") + 1);
				String oct4 = resposta.substring(resposta.indexOf(".") + 1);

				short int1 = Short.parseShort(oct1);
				short int2 = Short.parseShort(oct2);
				short int3 = Short.parseShort(oct3);
				short int4 = Short.parseShort(oct4);
				String hex1 = Integer.toHexString(int1);
				String hex2 = Integer.toHexString(int2);
				String hex3 = Integer.toHexString(int3);
				String hex4 = Integer.toHexString(int4);
				short soct1 = Short.parseShort(hex1, 16);
				short soct2 = Short.parseShort(hex2, 16);
				short soct3 = Short.parseShort(hex3, 16);
				short soct4 = Short.parseShort(hex4, 16);
				short aux1 = (short) (soct1 << 8);
				aux1 |= soct2;
				short aux2 = (short) (soct3 << 8);
				aux2 |= soct4;

				Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_IP_1] = reverseBytes(aux1);
				Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_IP_2] = reverseBytes(aux2);

			} catch (Exception e) {

			}

		}

	}

	public static short reverseBytes(short i) {

		return (short) (((i & 0xFF00) >> 8) | (i << 8));
	}

	public byte[] recebeBytes(InputStream a) {

		int tamanhoBuffer;
		byte[] buffer = new byte[1500];
		byte[] entradaBytes;
		byte[] resposta = null;
		int i = 0;
		int j;

		try {

			if (a.available() > 0) {

				Timer.setTimeOutInatividade(this.tempoInatividade);

				ThreadWatchDog.resetWatchDog();

				GPIO.getInstance().ledRST(1 << 0);

				tamanhoBuffer = a.read(buffer);

				entradaBytes = new byte[tamanhoBuffer]; // criando um array

				entradaBytes = buffer;

				i = tamanhoBuffer;

				numeroMensagensTrafegadasRoteamento++;

				Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_NUM_MSG_TRA_ROT] = reverseBytes((short) numeroMensagensTrafegadasRoteamento);

				bytesRoteamento += tamanhoBuffer;

				AtualizarBytesTrafegados(bytesRoteamento);

				if (isRoteandoerial()) {

					SERIAL1.getInstance().escreverComando(
							"[Info] Transmitidos " + tamanhoBuffer + " bytes para o equipamento");
				}

				int firstAddr = Ferramentas.convert2ByteHexToInt(entradaBytes, 2, 3);

				if (entradaBytes[1] == 4 && firstAddr >= 256) {

					Modbus.AtualizarEspelho();
				}

				if (tamanhoBuffer == 4) {// identifica o pacote de ping nas
											// letras binÃ¡rias

					// if(entradaBytes[0] == 108 && entradaBytes[1] == 117 &&
					// entradaBytes[2] == 112 && entradaBytes[3] == 97) {//l-108
					// u-117 p-112 a-97

					if (entradaBytes[0] == 76 && entradaBytes[1] == 85 && entradaBytes[2] == 80
							&& entradaBytes[3] == 65) {//

						if (i > 0) {

							resposta = new byte[i];

							for (j = 0; j < i; j++) {

								resposta[j] = entradaBytes[j];
							}
						}

						enviaBytes(resposta, outPutStream, socketRoteamento);

						return null;
					}
				}

				if (i > 0) {

					resposta = new byte[i];

					for (j = 0; j < i; j++) {

						resposta[j] = entradaBytes[j];
					}
				}
			}

			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
			}

			GPIO.getInstance().ledRST(0 << 0);
			return resposta;

		} catch (IOException e) {

			e.printStackTrace();
		}

		return resposta;

	}

	public static void AtualizarBytesTrafegados(int quantidadeBytes) {

		// conversao do bytes trafegados
		short byte1 = (short) (quantidadeBytes >> 16 & 0xffff);
		short byte2 = (short) (quantidadeBytes & 0xffff);

		Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_BYTES_ROTEAMENTO_1] = reverseBytes(byte1);
		Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_BYTES_ROTEAMENTO_2] = reverseBytes(byte2);

	}

	public void enviaBytes(byte[] msg, OutputStream out, SocketConnection sc) {

		if (isRoteandoerial()) {

			// Mensagem que aparece no terminal
			SERIAL1.getInstance().escreverComando("[Info] Recebidos " + msg.length + " bytes do equipamento");
		}

		try {

			GPIO.getInstance().ledRST(1 << 0);

			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
			}

			out.write(msg);
			out.flush();

			numeroMensagensTrafegadasRoteamento++;

			Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_NUM_MSG_TRA_ROT] = reverseBytes((short) numeroMensagensTrafegadasRoteamento);

			bytesRoteamento += msg.length;

			AtualizarBytesTrafegados(bytesRoteamento);

			GPIO.getInstance().ledRST(0 << 0);

		} catch (IOException e) {

		}

	}

	private void iniciarTimeOut() {

		if (DEBUG) {
			System.out.println("[log] Inicializando Timeouts");
		}
		this.tempoInatividade = SocketUtils.getInstance().lerTempoInatividadeSocketRoteamento();
		this.tempoManutencao = SocketUtils.getInstance().lerTempoManutencaoSocketRoteamento();
		this.tempoPermanenciaServidorRedundante = SocketUtils.getInstance().lerTempoPermanenciaServidorRedundante();
		ThreadTimeOutsRotemanto timeOuts = new ThreadTimeOutsRotemanto();
		ThreadTimeOutsRotemanto.loop = false;

		if (timeOuts.isAlive()) {

			ThreadTimeOutsRotemanto.loop = false;

			timeOuts.interrupt();

			timeOuts.start();

		} else {

			timeOuts.start();

		}

	}

	private void abrirSocketComunicacao() {

		SocketComunicacao.loop = false;
		SocketComunicacao.loopTimers = false;
		ThreadInatividadeComunicacao.loop = false;
		ThreadComunicacao socketComunicacao = new ThreadComunicacao();

		if (socketComunicacao.isAlive()) {
			ThreadInatividadeComunicacao.loop = false;
			SocketComunicacao.loop = false;
			SocketComunicacao.loopTimers = false;
			socketComunicacao.interrupt();
			socketComunicacao.start();

		} else {

			socketComunicacao.start();
		}
	}

	private void fecharConexoes() {
		// ThreadMonitoraPPP.loop = false; // retirada a thread PPP para aumento
		// de desempenho.
		ThreadTimeOutsFabricante.loop = false;
		SocketFabricante.loop = false;
		SocketFabricante.loopTimers = false;
		ThreadInatividadeComunicacao.loop = false;
		SocketComunicacao.loop = false;
		SocketComunicacao.loopTimers = false;
		ThreadLedConexao.estadoConexao = 1; // muda o stado da conexao
		setRoteandoSerial(false);
		;
		ThreadTimeOutsRotemanto.loop = false;
	}

	public void abrirConexao() {

		if (reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 1) {

			for (tentativasConexao = 1; tentativasConexao <= 3; tentativasConexao++) {// loop
																						// de
																						// conexao

				if (tentativasConexao == 3) {

					// System.out.println("ativa dns");

					ativarDns = true;

				} else {

					System.out.println("desativa dns");

					// ativarDns = false;
				}

				SERIAL1.getInstance().escreverComando(Prints.separador());

				GerenciadorConexao.getInstance().amostrasSinal();

				SERIAL1.getInstance().escreverComando(Prints.separador());

				SERIAL1.getInstance().escreverComando("[Info] Conectando no Servidor Roteamento de Mensagens");

				SERIAL1.getInstance().escreverComando(Prints.separador());

				try {
					Thread.sleep(7000);
				} catch (InterruptedException ignorada) {
				}

				ThreadWatchDog.resetWatchDog();

				carregaConfiguracoesConexao1(1, ativarDns);

				servidorPrincipal(); // Servidor principal

				if (ftpFlagBoot) {
					break;
				}

				if (!conectouOperadoraRedundante) {

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Trocando IP/PORTA de conexao");

					ThreadWatchDog.resetWatchDog();

					carregaConfiguracoesConexao1(2, ativarDns);

					SERIAL1.getInstance().escreverComando(Prints.separador());

					GerenciadorConexao.getInstance().amostrasSinal();

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

					SERIAL1.getInstance().escreverComando(Prints.separador());

					try {
						Thread.sleep(7000);
					} catch (InterruptedException ignorada) {
					}

					servidorRedundante();
				}

				if (ftpFlagBoot) {
					break;
				}

				GerenciadorDisponibilidade.getInstance().verificaContador();

				if (tentativasConexao == 3) {

					SERIAL1.getInstance().escreverComando("[Info] Reiniciando modulo");

					SERIAL1.getInstance().escreverComando(Prints.separador());

					verificaContadorReduncia();

					Modulo.desligar(true);

				} else {

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Trocando IP/PORTA de conexao");
				}

			}

		} else { // COM 2 cartoes sim

			for (tentativasConexao = 1; tentativasConexao <= 6; tentativasConexao++) {// loop
																						// de
																						// conexao

				if (tentativasConexao == 3 || tentativasConexao == 5) {

					System.out.println("ativa dns");

					ativarDns = true;

				} else {

					System.out.println("desativa dns");

					ativarDns = false;
				}

				SERIAL1.getInstance().escreverComando(Prints.separador());

				GerenciadorConexao.getInstance().amostrasSinal();

				SERIAL1.getInstance().escreverComando(Prints.separador());

				SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

				SERIAL1.getInstance().escreverComando(Prints.separador());

				try {
					Thread.sleep(7000);
				} catch (InterruptedException ignorada) {
				}

				ThreadWatchDog.resetWatchDog();

				carregaConfiguracoesConexao1(1, ativarDns); // CONFIGURA DADOS
															// SERVIDOR
															// PRINCIPAL/
															// ATIVACACAO DO DNS

				servidorPrincipal(); // SERVIDOR PRINCIPAL

				if (ftpFlagBoot) {
					break;
				} // BREAK PARA A MODO DE ATUALIZACAO

				if (!conectouOperadoraRedundante && !trocaSimCard || conectouOperadoraRedundante && !trocaSimCard) {

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Trocando IP/PORTA de conexao1");

					ThreadWatchDog.resetWatchDog();

					carregaConfiguracoesConexao1(2, ativarDns); // INFO SERVIDOR
																// REDUNDANTE/
																// ATIVACACAO DO
																// DNS

					SERIAL1.getInstance().escreverComando(Prints.separador());

					GerenciadorConexao.getInstance().amostrasSinal();

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

					SERIAL1.getInstance().escreverComando(Prints.separador());

					try {
						Thread.sleep(7000);
					} catch (InterruptedException ignorada) {
					}

					servidorRedundante(); // CONEXAO SERVIDOR REDUNDANTE
				}

				if (ftpFlagBoot) {
					break;
				} // BREAK PARA A MODO DE ATUALIZACAO

				GerenciadorDisponibilidade.getInstance().verificaContador();

				if (tentativasConexao == 3 || trocaSimCard) {

					ThreadWatchDog.resetWatchDog();

					if (!conectouServidorRedundante) {

						GerenciadorConexao.getInstance().desconectarApn();

						if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 1) {

							if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
									&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1) {

								if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_NIV_PRI]) == 1) {

									ThreadWatchDog.resetWatchDog();
									SERIAL1.getInstance().escreverComando("[Info] Trocando para o SIM CARD redundante");
									SERIAL1.getInstance().escreverComando(Prints.separador());

								} else {

									SERIAL1.getInstance().escreverComando("[Info] Trocando para o SIM CARD principal");
									SERIAL1.getInstance().escreverComando(Prints.separador());

								}

								ThreadLedConexao.estadoConexao = -1;

								try {
									Thread.sleep(100);
								} catch (InterruptedException e) {
								}

								GPIO.getInstance().ledCON(0 << 0);
								GPIO.getInstance().ledREG(0 << 0);
								GPIO.getInstance().ledERR(0 << 0);

								GerenciadorHardware.trocarSimCard(2);

								try {
									Thread.sleep(1000);
								} catch (InterruptedException e) {
								}

								GerenciadorHardware.trocarSimCard(2);

								try {
									Thread.sleep(5000);
								} catch (InterruptedException ingnorada) {
								} // tempo aumentado para garantir que nÃ£o sera
									// utilzado o mesmo sim

								SERIAL1.getInstance().escreverComando("[Info] SIM CARD 2 selecionado");
								SERIAL1.getInstance().escreverComando(Prints.separador());
								Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL] = reverseBytes((short) 2);

								ThreadWatchDog.resetWatchDog();
								SERIAL1.getInstance().escreverComando("[Info] Reiniciando conexao");
								SERIAL1.getInstance().escreverComando(Prints.separador());

								ThreadLedConexao.estadoConexao = -1;
								try {
									Thread.sleep(100);
								} catch (InterruptedException e) {
								}
								GPIO.getInstance().ledCON(0 << 0);
								GPIO.getInstance().ledREG(0 << 0);

								GerenciadorHardware.limparApns();
								GerenciadorConexao
										.getInstance()
										.configuraApnOperadora(
												reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]));
								GerenciadorConexao.getInstance().configuraTecnologia();
								try {
									Thread.sleep(10000);
								} catch (InterruptedException e) {
								}
								GerenciadorConexao.getInstance().registroRede();
								GerenciadorConexao.getInstance().registroOperadora();
								GerenciadorConexao.getInstance().conectarRede();
								GerenciadorConexao.getInstance().amostrasSinal();
								GerenciadorConexao.getInstance().registroApn3();
								ThreadWatchDog.resetWatchDog();

							} else {

								SERIAL1.getInstance().escreverComando("[Info] SIM CARD desabilitado ou nao inserido ");

								SERIAL1.getInstance().escreverComando(Prints.separador());

								SERIAL1.getInstance().escreverComando("[Info] Reiniciando modulo ");

								SERIAL1.getInstance().escreverComando(Prints.separador());

								Modulo.desligar(true);

							}

						} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 2) {

							if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
									&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1) {

								if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_NIV_PRI]) == 1) {

									ThreadWatchDog.resetWatchDog();

									SERIAL1.getInstance().escreverComando("[Info] Trocando para o SIM CARD redundante");
									SERIAL1.getInstance().escreverComando(Prints.separador());

								} else {

									SERIAL1.getInstance().escreverComando("[Info] Trocando para o SIM CARD principal");
									SERIAL1.getInstance().escreverComando(Prints.separador());

								}

								ThreadLedConexao.estadoConexao = -1;

								try {
									Thread.sleep(100);
								} catch (InterruptedException e) {
								}

								GPIO.getInstance().ledCON(0 << 0);
								GPIO.getInstance().ledREG(0 << 0);
								GPIO.getInstance().ledERR(0 << 0);

								GerenciadorHardware.trocarSimCard(1);
								try {
									Thread.sleep(1000);
								} catch (InterruptedException e) {
								}
								GerenciadorHardware.trocarSimCard(1);

								try {
									Thread.sleep(5000);
								} catch (InterruptedException ingnorada) {
								} // tempo aumentado para garantir que nÃ£o sera
									// utilzado o mesmo sim

								SERIAL1.getInstance().escreverComando("[Info] SIM CARD 1 selecionado");
								SERIAL1.getInstance().escreverComando(Prints.separador());

								Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL] = reverseBytes((short) 1);

								ThreadWatchDog.resetWatchDog();
								SERIAL1.getInstance().escreverComando("[Info] Reiniciando conexao");
								SERIAL1.getInstance().escreverComando(Prints.separador());

								ThreadLedConexao.estadoConexao = -1;
								try {
									Thread.sleep(100);
								} catch (InterruptedException e) {
								}
								GPIO.getInstance().ledCON(0 << 0);
								GPIO.getInstance().ledREG(0 << 0);

								GerenciadorHardware.limparApns();
								GerenciadorConexao
										.getInstance()
										.configuraApnOperadora(
												reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]));
								GerenciadorConexao.getInstance().configuraTecnologia();
								try {
									Thread.sleep(10000);
								} catch (InterruptedException e) {
								}
								GerenciadorConexao.getInstance().registroRede();
								GerenciadorConexao.getInstance().registroOperadora();
								GerenciadorConexao.getInstance().conectarRede();
								GerenciadorConexao.getInstance().amostrasSinal();
								GerenciadorConexao.getInstance().registroApn3();
								ThreadWatchDog.resetWatchDog();

							} else {
								SERIAL1.getInstance().escreverComando("[Info] SIM CARD desabilitado ou nao inserido ");

								SERIAL1.getInstance().escreverComando(Prints.separador());

								SERIAL1.getInstance().escreverComando("[Info] Reiniciando modulo ");

								SERIAL1.getInstance().escreverComando(Prints.separador());

								Modulo.desligar(true);
							}

						} else {

							SERIAL1.getInstance().escreverComando("[Info] Reiniciando modulo");

							SERIAL1.getInstance().escreverComando(Prints.separador());

						}

					}
				}

				if (tentativasConexao == 6) {

					SERIAL1.getInstance().escreverComando("[Info] Reiniciando modulo");

					SERIAL1.getInstance().escreverComando(Prints.separador());

					verificaContadorReduncia();

					Modulo.desligar(true);

				} else if (!trocaSimCard) {

					SERIAL1.getInstance().escreverComando(Prints.separador());

					SERIAL1.getInstance().escreverComando("[Info] Trocando IP/PORTA de conexao");
				} else {

					trocaSimCard = false;

				}

			}

		}

	}

	private void carregaTimers() {

		if (tempoPermanenciaServidorRedundante > 0 && conectouServidorRedundante) {

			Timer.setTimeOutDesconexaoServidorRedundante(this.tempoPermanenciaServidorRedundante);

		} else {

			Timer.setTimeOutDesconexaoServidorRedundante(-1);
		}

		if (this.tempoInatividade == 0) {

			Timer.setTimeOutInatividade(-1);

		} else {

			Timer.setTimeOutInatividade(this.tempoInatividade);
		}

		if (this.tempoManutencao == 0) {

			Timer.setTimeOutManutencao(-1);

		} else {

			Timer.setTimeOutManutencao(this.tempoManutencao);
		}

		if (this.tempoValidacao == 0) {

			this.tempoValidacao = Defines.timeoutValidacao * 10;
		}

		if (reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 2) {

			if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 2
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_NIV_PRI]) == 1) {

				Timer.setTimeOutDesconexaoOperadoraRedundante(this.tempoOperadoraRedundante);

			} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIMCARSEL]) == 1
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1
					&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_NIV_PRI]) == 1) {

				Timer.setTimeOutDesconexaoOperadoraRedundante(this.tempoOperadoraRedundante);

				conectouOperadoraRedundante = true;
			} else {

				Timer.setTimeOutDesconexaoOperadoraRedundante(-1);
			}

		} else {

			Timer.setTimeOutDesconexaoOperadoraRedundante(-1);

		}

	}

	private static byte[] sendDatagram(DatagramConnection connection, Datagram datagram, String msg) throws IOException {

		byte[] data = msg.getBytes();

		try {

			// São informções que estão vindo do equipamento atrvés da serial
			SERIAL1.getInstance().escreverComando("[Info] Recebidos " + data.length + " bytes do equipamento");

			GPIO.getInstance().ledRST(1 << 0);

			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {

			}

			datagram.setData(data, 0, data.length);

			connection.send(datagram);

			numeroMensagensTrafegadasRoteamento++;

			Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_NUM_MSG_TRA_ROT] = reverseBytes((short) numeroMensagensTrafegadasRoteamento);

			bytesRoteamento += data.length;

			AtualizarBytesTrafegados(bytesRoteamento);

			GPIO.getInstance().ledRST(0 << 0);

			return data;

		} catch (IOException e) {

			System.out.println("[alert] não foi possível enviar a mesagem ao servidor UDP");

			return null;

		}

	}

	private static byte[] receiveDatagram(DatagramConnection connection, Datagram datagram) throws IOException {

		byte[] byteData = datagram.getData();

		String recevie_ok = "ok";
		String receive_nok = "nok";

		connection.receive(datagram);

		if (byteData != null) {

			System.out.println("[info] " + datagram.getAddress());

			System.out.println("byteData: é diferente de null!");
			StringBuffer sb = new StringBuffer();

			for (int ccnt = 0; ccnt < byteData.length; ccnt++) {
				if (byteData[ccnt] > 0) {
					sb.append((char) byteData[ccnt]);
				} else {
					break;
				}

			}

			System.out.println("[info] mensagem recedida do servidor: " + sb);

		} else {

			System.out.println("[info] não foi recebido nada do servidor");
			return byteData;

		}
		return null;

	}

	private void servidorPrincipal() {

		conectouServidorRedundante = false;

		ftpFlagBoot = false;

		ThreadWatchDog.resetWatchDog();

		String msgTosend = "LUPATEC";

		String msg = null;

		byte msg_Send;

		// Conexão TCP/IP
		if (protocolo == 0) {

		}
		// Conexão UDP
		else {

			for (int i = 1; i <= tentativasConexaoServidor; i++) {

				ThreadLedConexao.estadoConexao = 1;
				setRoteandoSerial(false);
				Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY] = 0;
				Timer.setTimeOutInatividade(-1);
				Timer.setTimeOutManutencao(-1);
				Timer.setTimeOutDesconexaoOperadoraRedundante(-1);

				if (dnsAtivado) {

					SERIAL1.getInstance().escreverComando(
							"[Info] DNS: " + this.host + " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de "
									+ tentativasConexaoServidor);

				} else {

					SERIAL1.getInstance().escreverComando(
							"[Info] IP: " + this.host + " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de "
									+ tentativasConexaoServidor);
				}

				try {

					SERIAL1.getInstance().escreverComando("Abrindo Socket de Comunicação!");

					SERIAL1.getInstance().escreverComando(Prints.separador());

					DatagramConnection connection = (DatagramConnection) Connector.open("datagram://" + getHost() + ":"
							+ getPortaTCP(), Connector.READ_WRITE, true);

					conectouServidorRedundante = false;
					descTCP = false;
					ThreadLedConexao.estadoConexao = -1;

					this.tempoInatividade = SocketUtils.getInstance().lerTempoInatividadeSocketRoteamento();
					this.tempoManutencao = SocketUtils.getInstance().lerTempoManutencaoSocketRoteamento();
					this.tempoPermanenciaServidorRedundante = SocketUtils.getInstance()
							.lerTempoPermanenciaServidorRedundante();
					this.tempoOperadoraRedundante = SocketUtils.getInstance().lerTempoPermanenciaOperadoraRedundante();

					try {
						Thread.sleep(200);
					} catch (InterruptedException e1) {
					}

					GPIO.getInstance().ledCON(1 << 0);

					GPIO.getInstance().ledERR(0 << 0);

					carregaTimers();

					// Informações da Operadora
					String ip = socketRoteamento.getLocalAddress();
					identificaIpOperadora(ip);
					SERIAL1.getInstance().escreverComando("[Info] Conectado no Servidor Roteamento de Mensagens");
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando("[Info] IP do modem: " + ip);
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando(Prints.separador());

					// Como a conexão foi estabelecida é possível enviar e
					// receber mensagens
					while (tempoValidacao > 0) {

						datagram = connection.newDatagram(1000);

						// Esse msg deve ser algo que está vindo pala serial
						// do equipamento
						// Por equanto isso etá sendo simulado por uma
						// variável local
						sendDatagram(connection, datagram, msgTosend);

						// Se foi possível enviar a mensagem
						if (sendDgram) {

							// Cria um novo datagram
							datagram = connection.newDatagram(1000);

							// Aguarda uma reposta
							receiveDatagram(connection, datagram);

							try {
								Thread.sleep(100);
							} catch (InterruptedException e) {
							}

						} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY]) == 1) {

							if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_SERIAL1]) == 1) {

								i = modoRoteamentoMensagens485();

							} else {

								i = modoRoteamentoMensagens();
							}

						}

						tempoValidacao--;

					}
					if (Timer.getTimeOutInatividade() == 0) {

						SERIAL1.getInstance().escreverComando(
								"[Info] Desconectando da camada TCP por tempo de inatividade");
						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

					} else if (Timer.getTimeOutManutencao() == 0) {

						SERIAL1.getInstance().escreverComando(
								"[Info] Desconectando da camada TCP por tempo de manutencao");
						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

					} else if (Timer.getTimeOutDesconexaoServidorRedundante() == 0) {

						SERIAL1.getInstance().escreverComando(
								"[Info] Desconectando por tempo de permanencia no servidor redundante");
						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						i = tentativasConexaoServidor + 1;

					} else if (trocaSimCard) {

						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(
								"[Info] Socket TCP HS Roteamento de Mensagens desconectado");
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Trocando SIM CARD");
						i = tentativasConexaoServidor;

					} else if (Timer.getTimeOutDesconexaoOperadoraRedundante() == 0) {

						trocaSimCard = true;
						SERIAL1.getInstance().escreverComando(
								"[Info] Desconectando por tempo de permanencia na operadora redundante");
						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						conectouServidorRedundante = false;
						i = tentativasConexaoServidor + 1;

					} else if (descTCP) {

						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(
								"[Info] Socket TCP HS Roteamento de Mensagens desconectado");
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
					}

					if (tempoValidacao == 0) {

					} else if (descTCP) {

						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SERIAL1.getInstance().escreverComando(
								"[Info] Socket TCP HS Roteamento de Mensagens desconectado");
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
					}

					if (tempoValidacao == 0) {

						if (tentativasValidacao < 3) {

							SERIAL1.getInstance().escreverComando(
									"[Info] Reiniciando conexao TCP por tempo de validacao");
							Timer.setTimeOutInatividade(-1);
							Timer.setTimeOutManutencao(-1);
							Timer.setTimeOutDesconexaoServidorRedundante(-1);
							SocketComunicacao.loop = false;
							SocketComunicacao.loopTimers = false;
							ThreadInatividadeComunicacao.loop = false;
							SERIAL1.getInstance().escreverComando(Prints.separador());
							GerenciadorConexao.getInstance().amostrasSinal();
							SERIAL1.getInstance().escreverComando(Prints.separador());
							SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

						} else {

							SERIAL1.getInstance().escreverComando("[Info] Nao foi possivel realizar a conexao TCP");
							Timer.setTimeOutInatividade(-1);
							Timer.setTimeOutManutencao(-1);
							Timer.setTimeOutDesconexaoServidorRedundante(-1);
							SocketComunicacao.loop = false;
							SocketComunicacao.loopTimers = false;
							ThreadInatividadeComunicacao.loop = false;
						}

					}

					// fechar socket e as streams de I/O

				} catch (IOException e) {

					GPIO.getInstance().ledERR(1 << 0);

					SERIAL1.getInstance().escreverComando(
							"[Info] Falha na conexao ao Servidor de Roteamento de Mensagens");

					try {
						Thread.sleep(5000);
					} catch (InterruptedException ingnorada) {
					}

					e.printStackTrace();

					String erro = e.getMessage();

					if (erro.indexOf("error -121") > -1 && i == 2) {// Em alguns
																	// caso o
																	// attach
																	// a rede
																	// LTE
																	// acontece,
																	// mas
																	// existe¡
																	// trafego
																	// de
																	// dados.
																	// para
																	// evitar a
																	// indisponibilidade
																	// do modem
																	// ele
																	// utiliza o
																	// fallback
																	// para
																	// 2G/3G

						GerenciadorAtc.getInstance().enviarComandoAT("AT^SXRAT=1");
					}

				} finally {

					try {

						if (socketRoteamento != null) {
							socketRoteamento.close();

							if (DEBUG) {
								System.out.println("[log] Fechando socket roteamento");
							}
						}
					} catch (Exception ignorada) {
					}

					try {
						if (outPutStream != null) {
							outPutStream.flush();
							outPutStream.close();

							if (DEBUG) {
								System.out.println("[log] Fechando output roteamento");
							}
						}
					} catch (Exception ignorada) {
					}

					try {

						if (inputStream != null) {
							inputStream.close();

							if (DEBUG) {
								System.out.println("[log] Fechando input roteamento");
							}
						}

					} catch (Exception ignorada) {
					}

				}

			}// Fim do for que faz o número de tentativas

		}// Fim do else que verifica se é UDP ou não

	}// Fim da função servidor principal

	/*
	 * 
	 * private void servidorPrincipal() {
	 * 
	 * conectouServidorRedundante = false;
	 * 
	 * ftpFlagBoot = false;
	 * 
	 * ThreadWatchDog.resetWatchDog();
	 * 
	 * String msgTosend = "LUPATEC";
	 * 
	 * String msg = null;
	 * 
	 * byte msg_Send;
	 * 
	 * for (int i = 1; i <= tentativasConexaoServidor; i++) {
	 * 
	 * ThreadLedConexao.estadoConexao = 1; setRoteandoSerial(false);
	 * Mapa.getInstance
	 * ().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY] = 0;
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoOperadoraRedundante(-1);
	 * 
	 * if (dnsAtivado) {
	 * 
	 * SERIAL1.getInstance().escreverComando( "[Info] DNS: " + this.host +
	 * " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de " +
	 * tentativasConexaoServidor);
	 * 
	 * } else {
	 * 
	 * SERIAL1.getInstance().escreverComando( "[Info] IP: " + this.host +
	 * " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de " +
	 * tentativasConexaoServidor); }
	 * 
	 * try {
	 * 
	 * SERIAL1.getInstance().escreverComando("Abrindo Socket de Comunicação!");
	 * 
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * 
	 * if (this.protocolo == 0) {
	 * 
	 * socketRoteamento = (SocketConnection)
	 * Connector.open(this.paremetrosConexao); inputStream =
	 * socketRoteamento.openInputStream(); outPutStream =
	 * socketRoteamento.openOutputStream();
	 * 
	 * }
	 * 
	 * else {
	 * 
	 * DatagramConnection connection = (DatagramConnection)
	 * Connector.open("datagram://" + getHost() + ":" + getPortaTCP(),
	 * Connector.READ_WRITE, true);
	 * 
	 * while (sendDgram == true) {
	 * 
	 * // System.out.println("Criando uma datagram com 1000 bytes");
	 * 
	 * datagram = connection.newDatagram(1000);
	 * 
	 * // System.out.println("[info] Enviando a mensagem");
	 * 
	 * // Esse msg deve ser algo que está vindo pala serial // do equipamento //
	 * Por equanto isso etá sendo simulado por uma // variável local
	 * sendDatagram(connection, datagram, msgTosend);
	 * 
	 * if (sendDgram == true) {
	 * 
	 * datagram = connection.newDatagram(1000);
	 * 
	 * // Aqui quero saber qual é a resposta do servidor
	 * 
	 * msg = receiveDatagram(connection, datagram);
	 * SERIAL1.getInstance().escreverComando
	 * ("[info] Mensagem recebida do servidor:" + msg);
	 * //System.out.println("sendDgram == True");
	 * 
	 * } else { //System.out.println("sendDgram == Fause"); break;
	 * 
	 * }
	 * 
	 * }
	 * 
	 * }
	 * 
	 * conectouServidorRedundante = false; descTCP = false;
	 * ThreadLedConexao.estadoConexao = -1;
	 * 
	 * if (!DEBUG) { System.out.println("[log] socket roteamento aberto"); }
	 * 
	 * this.tempoValidacao =
	 * SocketUtils.getInstance().lerTempoValidacaoConexao() * 10;
	 * this.tempoInatividade =
	 * SocketUtils.getInstance().lerTempoInatividadeSocketRoteamento();
	 * this.tempoManutencao =
	 * SocketUtils.getInstance().lerTempoManutencaoSocketRoteamento();
	 * this.tempoPermanenciaServidorRedundante = SocketUtils.getInstance()
	 * .lerTempoPermanenciaServidorRedundante(); this.tempoOperadoraRedundante =
	 * SocketUtils.getInstance().lerTempoPermanenciaOperadoraRedundante();
	 * 
	 * try { Thread.sleep(200); } catch (InterruptedException e1) { }
	 * 
	 * GPIO.getInstance().ledCON(1 << 0);
	 * 
	 * GPIO.getInstance().ledERR(0 << 0);
	 * 
	 * carregaTimers();
	 * 
	 * String ip = socketRoteamento.getLocalAddress();
	 * identificaIpOperadora(ip); SERIAL1.getInstance().escreverComando(
	 * "[Info] Conectado no HS Roteamento de Mensagens");
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance().escreverComando("[Info] IP do modem: " + ip);
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Horus aguardando validacao");
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * 
	 * while (tempoValidacao > 0) {
	 * 
	 * if (Modbus.getInstance().getMensagem(recebeBytes(inputStream))) {
	 * 
	 * enviaBytes(Modbus.getInstance().getRespostaMod(), outPutStream,
	 * socketRoteamento);
	 * 
	 * Modbus.getInstance().zeraResposta();
	 * 
	 * this.tempoValidacao =
	 * SocketUtils.getInstance().lerTempoValidacaoConexao() * 10;
	 * 
	 * } else if
	 * (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance
	 * ().Hold_MODO_GPRS_STANDBY]) == 1) {
	 * 
	 * if
	 * (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance()
	 * .Hold_MODO_SERIAL1]) == 1) {
	 * 
	 * i = modoRoteamentoMensagens485();
	 * 
	 * } else {
	 * 
	 * i = modoRoteamentoMensagens(); }
	 * 
	 * } else if
	 * (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance
	 * ().Hold_MODO_GPRS_STANDBY]) == 2) { // Modo // stand // by
	 * 
	 * i = modoStandBy(); }
	 * 
	 * tempoValidacao--;
	 * 
	 * if (DEBUG) { System.out.println("[log] Tempo validacao: " +
	 * this.tempoValidacao); }
	 * 
	 * try { Thread.sleep(100); } catch (InterruptedException e) { } }
	 * 
	 * if (Timer.getTimeOutInatividade() == 0) {
	 * 
	 * SERIAL1.getInstance() .escreverComando(
	 * "[Info] Desconectando da camada TCP por tempo de inatividade");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
	 * 
	 * } else if (Timer.getTimeOutManutencao() == 0) {
	 * 
	 * SERIAL1.getInstance().escreverComando(
	 * "[Info] Desconectando da camada TCP por tempo de manutencao");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
	 * 
	 * } else if (Timer.getTimeOutDesconexaoServidorRedundante() == 0) {
	 * 
	 * SERIAL1.getInstance().escreverComando(
	 * "[Info] Desconectando por tempo de permanencia no servidor redundante");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal(); i =
	 * tentativasConexaoServidor + 1;
	 * 
	 * } else if (trocaSimCard) {
	 * 
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando
	 * ("[Info] Socket TCP HS Roteamento de Mensagens desconectado");
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance().escreverComando("[Info] Trocando SIM CARD"); i =
	 * tentativasConexaoServidor;
	 * 
	 * } else if (Timer.getTimeOutDesconexaoOperadoraRedundante() == 0) {
	 * 
	 * trocaSimCard = true; SERIAL1.getInstance().escreverComando(
	 * "[Info] Desconectando por tempo de permanencia na operadora redundante");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * conectouServidorRedundante = false; i = tentativasConexaoServidor + 1;
	 * 
	 * } else if (descTCP) {
	 * 
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando
	 * ("[Info] Socket TCP HS Roteamento de Mensagens desconectado");
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Conectando no HS Roteamento de Mensagens"); }
	 * 
	 * if (tempoValidacao == 0) {
	 * 
	 * } else if (descTCP) {
	 * 
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1);
	 * SERIAL1.getInstance().escreverComando
	 * ("[Info] Socket TCP HS Roteamento de Mensagens desconectado");
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Conectando no HS Roteamento de Mensagens"); }
	 * 
	 * if (tempoValidacao == 0) {
	 * 
	 * if (tentativasValidacao < 3) {
	 * 
	 * SERIAL1.getInstance().escreverComando(
	 * "[Info] Reiniciando conexao TCP por tempo de validacao");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1); SocketComunicacao.loop
	 * = false; SocketComunicacao.loopTimers = false;
	 * ThreadInatividadeComunicacao.loop = false;
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * GerenciadorConexao.getInstance().amostrasSinal();
	 * SERIAL1.getInstance().escreverComando(Prints.separador());
	 * SERIAL1.getInstance
	 * ().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
	 * 
	 * } else {
	 * 
	 * SERIAL1.getInstance().escreverComando(
	 * "[Info] Nao foi possivel realizar a conexao TCP");
	 * Timer.setTimeOutInatividade(-1); Timer.setTimeOutManutencao(-1);
	 * Timer.setTimeOutDesconexaoServidorRedundante(-1); SocketComunicacao.loop
	 * = false; SocketComunicacao.loopTimers = false;
	 * ThreadInatividadeComunicacao.loop = false; }
	 * 
	 * }
	 * 
	 * // fechar socket e as streams de I/O
	 * 
	 * } catch (IOException e) {
	 * 
	 * GPIO.getInstance().ledERR(1 << 0);
	 * 
	 * SERIAL1.getInstance().escreverComando(
	 * "[Info] Falha na conexao ao Servidor de Roteamento de Mensagens");
	 * 
	 * try { Thread.sleep(5000); } catch (InterruptedException ingnorada) { }
	 * 
	 * e.printStackTrace();
	 * 
	 * String erro = e.getMessage();
	 * 
	 * if (erro.indexOf("error -121") > -1 && i == 2) {// Em alguns // caso o
	 * attach // a rede LTE // acontece, mas // existe¡ // trafego de // dados.
	 * para // evitar a // indisponibilidade // do modem ele // utiliza o //
	 * fallback para // 2G/3G
	 * 
	 * GerenciadorAtc.getInstance().enviarComandoAT("AT^SXRAT=1"); }
	 * 
	 * } finally {
	 * 
	 * try {
	 * 
	 * if (socketRoteamento != null) { socketRoteamento.close();
	 * 
	 * if (DEBUG) { System.out.println("[log] Fechando socket roteamento"); } }
	 * } catch (Exception ignorada) { }
	 * 
	 * try { if (outPutStream != null) { outPutStream.flush();
	 * outPutStream.close();
	 * 
	 * if (DEBUG) { System.out.println("[log] Fechando output roteamento"); } }
	 * } catch (Exception ignorada) { }
	 * 
	 * try {
	 * 
	 * if (inputStream != null) { inputStream.close();
	 * 
	 * if (DEBUG) { System.out.println("[log] Fechando input roteamento"); } }
	 * 
	 * } catch (Exception ignorada) { }
	 * 
	 * }
	 * 
	 * // try {Thread.sleep(5000);} catch (InterruptedException ingnorada) // {}
	 * } }
	 */

	private void servidorRedundante() {

		ftpFlagBoot = false;

		ThreadWatchDog.resetWatchDog();

		for (int i = 1; i <= tentativasConexaoServidor; i++) {

			ThreadLedConexao.estadoConexao = 1;
			setRoteandoSerial(false);
			Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY] = 0;
			Timer.setTimeOutInatividade(-1);
			Timer.setTimeOutManutencao(-1);

			if (dnsAtivado) {

				SERIAL1.getInstance().escreverComando(
						"[Info] DNS: " + this.host + " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de "
								+ tentativasConexaoServidor);

			} else {

				SERIAL1.getInstance().escreverComando(
						"[Info] IP: " + this.host + " , PORTA: " + portaTCP + " - " + "Tentativa " + i + " de "
								+ tentativasConexaoServidor);
			}

			try {
				datagramConnection = (DatagramConnection) Connector.open("datagram://" + this.host + ":"
						+ this.portaTCP);
				/*
				 * socketRoteamento = (SocketConnection)
				 * Connector.open(this.paremetrosConexao);
				 * 
				 * inputStream = socketRoteamento.openInputStream();
				 * outPutStream = socketRoteamento.openOutputStream();
				 * conectouServidorRedundante = true;
				 */
				ThreadLedConexao.estadoConexao = -1;

				if (DEBUG) {
					System.out.println("[log] socket roteamento aberto");
				}

				this.tempoValidacao = SocketUtils.getInstance().lerTempoValidacaoConexao() * 10;
				this.tempoInatividade = SocketUtils.getInstance().lerTempoInatividadeSocketRoteamento();
				this.tempoManutencao = SocketUtils.getInstance().lerTempoManutencaoSocketRoteamento();
				this.tempoPermanenciaServidorRedundante = SocketUtils.getInstance()
						.lerTempoPermanenciaServidorRedundante();
				this.tempoOperadoraRedundante = SocketUtils.getInstance().lerTempoPermanenciaOperadoraRedundante();

				try {
					Thread.sleep(200);
				} catch (InterruptedException e1) {
				}

				GPIO.getInstance().ledCON(1 << 0);

				GPIO.getInstance().ledERR(0 << 0);

				carregaTimers();

				String ip = socketRoteamento.getLocalAddress();

				identificaIpOperadora(ip);

				SERIAL1.getInstance().escreverComando("[Info] Conectado no HS Roteamento de Mensagens");
				SERIAL1.getInstance().escreverComando(Prints.separador());
				SERIAL1.getInstance().escreverComando("[Info] IP do modem: " + ip);
				SERIAL1.getInstance().escreverComando(Prints.separador());
				SERIAL1.getInstance().escreverComando("[Info] Horus aguardando validacao");
				SERIAL1.getInstance().escreverComando(Prints.separador());

				if (DEBUG) {

					System.out.println("[log] Tempo de validacao: " + this.tempoValidacao);
					System.out.println("[log] Tempo inativdade: " + this.tempoInatividade);
					System.out.println("[log] Tempo de manutencao: " + this.tempoManutencao);

				}
				while (tempoValidacao > 0) {

					if (Modbus.getInstance().getMensagem(recebeBytes(inputStream))) {

						enviaBytes(Modbus.getInstance().getRespostaMod(), outPutStream, socketRoteamento);

						Modbus.getInstance().zeraResposta();

					} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY]) == 1) {

						if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_SERIAL1]) == 1) {

							i = modoRoteamentoMensagens485();

						} else {

							i = modoRoteamentoMensagens();
						}

					} else if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_MODO_GPRS_STANDBY]) == 2) { // Modo
																																		// stand
																																		// by

						i = modoStandBy();
					}

					tempoValidacao--;

					if (DEBUG) {
						System.out.println("[log] Tempo validacao: " + this.tempoValidacao);
					}

					try {
						Thread.sleep(100);
					} catch (InterruptedException ignorada) {
					}

				}

				if (Timer.getTimeOutInatividade() == 0) {

					SERIAL1.getInstance()
							.escreverComando("[Info] Desconectando da camada TCP por tempo de inatividade");
					Timer.setTimeOutInatividade(-1);
					Timer.setTimeOutManutencao(-1);
					Timer.setTimeOutDesconexaoServidorRedundante(-1);
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

				} else if (Timer.getTimeOutManutencao() == 0) {

					SERIAL1.getInstance().escreverComando("[Info] Desconectando da camada TCP por tempo de manutencao");
					Timer.setTimeOutInatividade(-1);
					Timer.setTimeOutManutencao(-1);
					Timer.setTimeOutDesconexaoServidorRedundante(-1);
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

				} else if (Timer.getTimeOutDesconexaoServidorRedundante() == 0) {
					SERIAL1.getInstance().escreverComando(
							"[Info] Desconectando por tempo de permanencia no servidor redundante");
					Timer.setTimeOutInatividade(-1);
					Timer.setTimeOutManutencao(-1);
					Timer.setTimeOutDesconexaoServidorRedundante(-1);
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					i = tentativasConexaoServidor + 1;

				} else if (trocaSimCard) {

					SERIAL1.getInstance().escreverComando("[Info] Socket TCP HS Roteamento de Mensagens desconectado");
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando("[Info] Trocando SIM CARD");
					i = tentativasConexaoServidor;

				} else if (Timer.getTimeOutDesconexaoOperadoraRedundante() == 0) {

					trocaSimCard = true;
					SERIAL1.getInstance().escreverComando(
							"[Info] Desconectando por tempo de permanencia na operadora redundante");
					Timer.setTimeOutInatividade(-1);
					Timer.setTimeOutManutencao(-1);
					Timer.setTimeOutDesconexaoOperadoraRedundante(-1);
					Timer.setTimeOutDesconexaoServidorRedundante(-1);
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					SERIAL1.getInstance().escreverComando(Prints.separador());
					conectouServidorRedundante = false;
					i = tentativasConexaoServidor + 1;

				} else if (descTCP) {

					SERIAL1.getInstance().escreverComando("[Info] Socket TCP HS Roteamento de Mensagens desconectado");
					SERIAL1.getInstance().escreverComando(Prints.separador());
					GerenciadorConexao.getInstance().amostrasSinal();
					SERIAL1.getInstance().escreverComando(Prints.separador());
					SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");
				}

				if (tempoValidacao == 0) {

					if (tentativasValidacao <= 2) {

						SERIAL1.getInstance().escreverComando("[Info] Reiniciando conexao TCP por tempo de validacao");
						Timer.setTimeOutInatividade(-1);
						Timer.setTimeOutManutencao(-1);
						Timer.setTimeOutDesconexaoServidorRedundante(-1);
						SocketComunicacao.loop = false;
						SocketComunicacao.loopTimers = false;
						ThreadInatividadeComunicacao.loop = false;
						SERIAL1.getInstance().escreverComando(Prints.separador());
						GerenciadorConexao.getInstance().amostrasSinal();
						SERIAL1.getInstance().escreverComando(Prints.separador());
						SERIAL1.getInstance().escreverComando("[Info] Conectando no HS Roteamento de Mensagens");

					} else {

						ThreadLedConexao.estadoConexao = -1;
						try {
							Thread.sleep(100);
						} catch (InterruptedException e) {
						}
						GPIO.getInstance().ledCON(0 << 0);
						GPIO.getInstance().ledREG(0 << 0);
						SERIAL1.getInstance().escreverComando("[Info] Reiniciando por tempo de validacao da conexao");
						SERIAL1.getInstance().escreverComando("[Info] Reinicando modulo");
						SERIAL1.getInstance().escreverComando(Prints.separador());
						Modulo.desligar(true);

					}

				}

			} catch (IOException e) {

				GPIO.getInstance().ledERR(1 << 0);

				// SERIAL1.getInstance().escreverComando("[Info] Falha na conexao ao HS Roteamento de Mensagens");

				try {
					Thread.sleep(5000);
				} catch (InterruptedException ingnorada) {
				}

				e.printStackTrace();

				String erro = e.getMessage();

				if (erro.indexOf("error -121") > -1 && i == 2) {

					GerenciadorAtc.getInstance().enviarComandoAT("AT^SXRAT=1");
				}

			} finally {

				try {

					if (socketRoteamento != null) {
						socketRoteamento.close();

						if (DEBUG) {
							System.out.println("[log] Fechando socket roteamento");
						}
					}

				} catch (Exception ignorada) {
				}

				try {

					if (outPutStream != null) {
						outPutStream.flush();
						outPutStream.close();

						if (DEBUG) {
							System.out.println("[log] Fechando output roteamento");
						}
					}

				} catch (Exception ignorada) {
				}

				try {

					if (inputStream != null) {
						inputStream.close();

						if (DEBUG) {
							System.out.println("[log] Fechando input roteamento");
						}
					}

				} catch (Exception ignorada) {
				}
			}

			// try {Thread.sleep(5000);} catch (InterruptedException ingnorada)
			// {}
		}

	}

	private int modoStandBy() {
		int i;
		iniciarTimeOut();
		i = 0; // reinicia o numero de tentativas conexao ao servidor
		tentativasConexao = 0;// reinicia o numero de tentativas no loop
								// principal
		GPIO.getInstance().ledERR(0 << 0);
		SERIAL1.getInstance().escreverComando("[Info] Horus validado e em standby");
		loopTimers = true;
		abrirSocketComunicacao();

		tempoValidacao = -1;

		while (loopTimers) {

			try {
				socketRoteamento.getLocalPort();
			} catch (IOException e)

			{
				descTCP = true;
				loopTimers = false;
				e.printStackTrace();

			} // fica observando a conexão da porta TCP.

			if (Modbus.getInstance().getMensagem(recebeBytes(inputStream))) {

				enviaBytes(Modbus.getInstance().getRespostaMod(), outPutStream, socketRoteamento);

				Modbus.getInstance().zeraResposta();
			}

			GPIO.getInstance().ledERR(1 << 0);

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
			}

			GPIO.getInstance().ledERR(0 << 0);

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
			}

			if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_FTP_FLAG_BOOTLOADER]) == 1) {

				if (DEBUG) {
					System.out.println("Chamada para bootloader");
				}

				ftpFlagBoot = true;
				loopTimers = false;
				loopConexao = false;
				conectouServidorRedundante = false;
				flagReinicaInatividade = 0;
				Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_FTP_FLAG_BOOTLOADER] = 0;
				i = 4;
				EEPROM.getInstance().escreverShort(reverseBytes((short) 0), EEPROM.ADD_FTP_FLAG_BOOTLOADER * 2);
				Timer.setTimeOutInatividade(-1);
				Timer.setTimeOutManutencao(-1);
				Timer.setTimeOutInatividadeComunicacao(-1);
				Timer.setTimeOutDesconexaoServidorRedundante(-1);
				Timer.setTimeOutDesconexaoOperadoraRedundante(-1);
			}

			if (estadoCMD && reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 2) {

				if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1) {
					trocaSimCard = true;
					loopTimers = false;
					estadoCMD = false;//
				}

			}

		}

		fecharConexoes();
		return i;
	}

	private int modoRoteamentoMensagens() {

		int i;
		iniciarTimeOut();
		i = 0; // reinicia o numero de tentativas conexao ao servidor
		tentativasConexao = 0;// reinicia o numero de tentativas no loop
								// principal
		// Leds.getInstance().ledERR(0 << 0);
		SERIAL1.getInstance().escreverComando("[Info] Horus validado e roteando mensagens para serial 1 (RS-232)");
		setRoteandoSerial(true);
		tempoValidacao = -1;
		loopTimers = true;

		if (DEBUG) {
			System.out.println("[log] Abrindo socket comunicacao");
		}

		abrirSocketComunicacao();

		if (DEBUG) {
			System.out.println("[log] Horus validado e roteando mensagens");
		}

		while (loopTimers) {

			try {
				socketRoteamento.getLocalPort();
			} catch (IOException e) { // fica verificando a porta para ver se a
										// conexao estÃ¡ ativa.

				descTCP = true;
				loopTimers = false;
			}

			buffer1 = SERIAL0.getInstance().lerBytes();

			if (buffer1 != null) {

				enviaBytes(buffer1, outPutStream, socketRoteamento);
			}

			SERIAL0.getInstance().escreverBytes(recebeBytes(inputStream), 0);

			i = iniciaBootLoader(i);

			if (estadoCMD && reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 2) {

				if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1) {
					trocaSimCard = true;
					loopTimers = false;
					estadoCMD = false;//
				}

			}
		}

		fecharConexoes();

		return i;
	}

	private int iniciaBootLoader(int i) {
		if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_FTP_FLAG_BOOTLOADER]) == 1) {

			if (DEBUG) {
				System.out.println("Chamada para bootloader");
			}

			descTCP = false;
			ftpFlagBoot = true;
			loopTimers = false;
			loopConexao = false;
			conectouServidorRedundante = false;
			flagReinicaInatividade = 0;
			Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_FTP_FLAG_BOOTLOADER] = 0;
			i = 4;
			EEPROM.getInstance().escreverShort(reverseBytes((short) 0), EEPROM.ADD_FTP_FLAG_BOOTLOADER * 2);
			Timer.setTimeOutInatividade(-1);
			Timer.setTimeOutManutencao(-1);
			Timer.setTimeOutDesconexaoServidorRedundante(-1);
			fecharConexoes();
		}
		return i;
	}

	private int modoRoteamentoMensagens485() {

		int i;

		iniciarTimeOut();
		i = 0; // reinicia o numero de tentativas conexao ao servidor
		tentativasConexao = 0;// reinicia o numero de tentativas no loop
								// principal
		// Leds.getInstance().ledERR(0 << 0);
		SERIAL1.getInstance().escreverComando("[Info] Horus validado e roteando mensagens para serial 1 (RS-485)");
		setRoteandoSerial(true);
		tempoValidacao = -1;
		loopTimers = true;

		if (DEBUG) {
			System.out.println("[log] Abrindo socket comunicacao");
		}

		abrirSocketComunicacao();

		if (DEBUG) {
			System.out.println("[log] Horus validado e roteando mensagens");
		}

		if (DEBUG) {
			System.out.println("[log] Horus validado e roteando mensagens");
		}

		while (loopTimers) {

			try {
				socketRoteamento.getLocalPort();
			} catch (IOException e) { // fica verificando a porta para ver se a
										// conexao estÃ¡ ativa.

				descTCP = true;
				loopTimers = false;
			}

			// buffer1 = SERIAL0.getInstance().lerBytes();

			buffer1 = SERIAL0485.getInstance().lerBytes();

			if (buffer1 != null) {

				enviaBytes(buffer1, outPutStream, socketRoteamento);
			}

			SERIAL0485.getInstance().escreverBytes(recebeBytes(inputStream), 0);

			i = iniciaBootLoader(i);

			if (estadoCMD && reverseBytes(Mapa.getInstance().mapInputRegister[Mapa.getInstance().ADD_TIPO_HARDW]) == 2) {

				if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM1]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2_EST_CAR]) == 1
						&& reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_SIM2]) == 1) {
					trocaSimCard = true;
					loopTimers = false;
					estadoCMD = false;//
				}
			}
		}

		fecharConexoes();

		return i;
	}

	public void verificaContadorReduncia() {

		if (reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_CONTADOR_REDUNDANCIA]) == 0) {

			short valor = reverseBytes(Mapa.getInstance().mapHoldingRegisters[Mapa.getInstance().Hold_CONTADOR_REDUNDANCIA]);

			valor += 1;

			if (valor == 6) {

				EEPROM.getInstance().escreverShort(reverseBytes((short) 1),
						Mapa.getInstance().Hold_ATIVAR_REDUNDANCIA_APN * 2);

			}

		}

	}

	public boolean verificaDnsPrimarioCemig() {

		String primario = SocketUtils.getInstance().lerDnsPirmario();

		if ((SocketUtils.getInstance().simIP1(1).indexOf("177.207.193.149") > -1)) { // testado

			return false;

		} else if ((SocketUtils.getInstance().simIP1(1).indexOf("187.32.79.172") > -1)) { // teste

			return false;

		} else if (primario.indexOf("cemig") > -1) { // testado

			return true;

		} else {

			return false;

		}

	}

	public boolean verificaDnsSecundarioCemig() {

		String secundario = SocketUtils.getInstance().lerDnsSecundario();

		if ((SocketUtils.getInstance().simIP1(1).indexOf("177.207.193.149") > -1)) {

			return false;

		} else if ((SocketUtils.getInstance().simIP1(1).indexOf("187.32.79.172") > -1)) {

			return false;

		} else if (secundario.indexOf("cemig") > -1) {

			return true;

		} else {

			return false;

		}
	}

	public boolean ativaDns(int servidor, int simcard) {

		if (servidor == 1) {

			if (simcard == 1) {

				return SocketUtils.getInstance().simIP1(1).equals("0.0.0.0");

			} else {

				return SocketUtils.getInstance().simIP1(2).equals("0.0.0.0");

			}

		} else {

			if (simcard == 1) {

				return SocketUtils.getInstance().simIP2(1).equals("0.0.0.0");

			} else {

				return SocketUtils.getInstance().simIP2(2).equals("0.0.0.0");
			}

		}

	}

	public static boolean verificaRange(String hostMin, String hostMax, String ipToCheck) { // realiza
																							// a
																							// comparacao
																							// atraves
																							// do
																							// ips
																							// convertidos
																							// em
																							// log

		try {

			long ipLo = ipToLong((hostMin));
			long ipHi = ipToLong((hostMax));
			long ipToTest = ipToLong(ipToCheck);

			return (ipToTest >= ipLo && ipToTest <= ipHi);

		} catch (Error e) {

			System.out.println("[Socket2] Erro verificaRange");

			return false;
		}
	}

	public static long ipToLong(String ipAddress) { // converte ip em long

		long result = 0;

		try {

			String[] ipAddressInArray = stringToArrayString(ipAddress);

			for (int i = 3; i >= 0; i--) {

				long ip = Long.parseLong(ipAddressInArray[3 - i]);

				result |= ip << (i * 8);
			}

		} catch (Exception e) {

			System.out.println("[Socket2] Erro ipToLong");
		}

		return result;
	}

	public static String[] stringToArrayString(String ip) {

		String[] strArray = new String[4];

		try {

			if (ip != null) {

				String oct1_1 = ip.substring(0, ip.indexOf("."));
				String oct1_2 = ip.substring(ip.indexOf(".") + 1, ip.indexOf(".", ip.indexOf(".") + 2));
				ip = ip.substring(ip.indexOf(".") + 1);
				String oct2_1 = ip.substring(ip.indexOf(".") + 1, ip.indexOf(".", ip.indexOf(".") + 2));
				ip = ip.substring(ip.indexOf(".") + 1);
				String oct2_2 = ip.substring(ip.indexOf(".") + 1);

				strArray[0] = oct1_1;
				strArray[1] = oct1_2;
				strArray[2] = oct2_1;
				strArray[3] = oct2_2;
			}

		} catch (Exception e) {

			System.out.println("[Socket2] Erro stringToArrayString");
		}

		return strArray;

	}
}
